diff --git oak_proto_rust/BUILD oak_proto_rust/BUILD
index f33e74c6e..f8a021692 100644
--- oak_proto_rust/BUILD
+++ oak_proto_rust/BUILD
@@ -52,6 +52,7 @@ cargo_build_script(
     ],
     build_script_env = {
         "PROTOC": "$(execpath @com_google_protobuf//:protoc)",
+        "DESCRIPTOR_PROTO_PATH": "$(location @com_google_protobuf//:descriptor_proto_srcs)",
     },
     crate_features = ["bazel"],  # See b/340185847 and fix_prost_derives function doc.
     data = [
@@ -72,7 +73,7 @@ cargo_build_script(
         "//proto/oak_functions:testing_proto",
         "//proto/oak_functions/service:oak_functions_proto",
         "//proto/session:session_proto",
-        "@com_google_protobuf//:descriptor_proto",
+        "@com_google_protobuf//:descriptor_proto_srcs",
         "@com_google_protobuf//:well_known_type_protos",
     ],
     tools = [
@@ -82,7 +83,6 @@ cargo_build_script(
         "//micro_rpc_build",
         "//oak_proto_build_utils",
         "@oak_crates_index//:prost-build",
-        "@rules_rust//tools/runfiles",
     ],
 )
 
diff --git oak_proto_rust/build.rs oak_proto_rust/build.rs
index c20f54355..2b40b6e42 100644
--- oak_proto_rust/build.rs
+++ oak_proto_rust/build.rs
@@ -18,28 +18,20 @@ use std::path::PathBuf;
 
 #[cfg(feature = "bazel")]
 fn get_included_protos() -> Vec<PathBuf> {
-    const WELL_KNOWN_PROTOS_PATH: &str = "com_google_protobuf/src";
-    extern crate runfiles;
-    let r = runfiles::Runfiles::create().unwrap();
-
     // The root of all Oak protos
     let oak_proto_root = PathBuf::from("..");
-
-    // When the build script runs in "bazel" mode, the google protobufs don't
-    // automatically end up in the include path for calls to protoc.
-
-    // The "well known" proto types provided by Google's protobuf library.
-    // These come from the "@com_google_protobuf//:well_known_type_protos" dep.
-    let well_known_google_protos_path = r.rlocation(WELL_KNOWN_PROTOS_PATH);
-
-    // descriptor.proto is not part of "well known protos", but we use it for
-    // micro_rpc, so it gets included as well.
-    // Comes from the "@com_google_protobuf//:descriptor_proto" dep.
-    let google_descriptor_proto_path = r.rlocation(format!(
-        "{WELL_KNOWN_PROTOS_PATH}/google/protobuf/_virtual_imports/descriptor_proto"
-    ));
-
-    vec![oak_proto_root, well_known_google_protos_path, google_descriptor_proto_path]
+    // Rely on bazel make variable `location` to find protobuf include paths.
+    // We do this as protobuf might be imported under different names in the
+    // external directory based on the setup (BzlMod, WORKSPACE or others).
+    // Possible names are: com_google_protobuf, protobuf~, and protobuf.
+    // The goal is to allow dependent repositories to use this
+    // library without renaming their explicit import of protobuf library.
+    let protobuf_include_path = PathBuf::from(
+        std::env::var("DESCRIPTOR_PROTO_PATH")
+            .unwrap()
+            .replace("google/protobuf/descriptor.proto", ""),
+    );
+    vec![oak_proto_root, protobuf_include_path]
 }
 
 #[cfg(not(feature = "bazel"))]

