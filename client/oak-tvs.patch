diff --git a/Cargo.lock b/Cargo.lock
index 9da55c87b..c35657ee4 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -2499,9 +2499,11 @@ name = "oak_containers_orchestrator"
 version = "0.1.0"
 dependencies = [
  "anyhow",
+ "async-stream",
  "ciborium",
  "clap",
  "coset",
+ "hex",
  "hpke",
  "log",
  "nix 0.27.1",
diff --git a/oak_containers_launcher/build.rs b/oak_containers_launcher/build.rs
index 1e60639fd..56ced5d23 100644
--- a/oak_containers_launcher/build.rs
+++ b/oak_containers_launcher/build.rs
@@ -24,8 +24,9 @@ fn main() -> Result<(), Box<dyn std::error::Error>> {
             "../proto/key_provisioning/key_provisioning.proto",
             "../proto/containers/hostlib_key_provisioning.proto",
             "../proto/session/messages.proto",
+            "../../../tvs/proto/tvs.proto",
         ],
-        &[".."],
+        &["..", "../../../"],
         CodegenOptions { build_client: true, build_server: true, ..Default::default() },
     )?;
 
diff --git a/oak_containers_launcher/src/lib.rs b/oak_containers_launcher/src/lib.rs
index 34631e623..95946d90c 100644
--- a/oak_containers_launcher/src/lib.rs
+++ b/oak_containers_launcher/src/lib.rs
@@ -32,6 +32,11 @@ pub mod proto {
             }
         }
     }
+    pub mod privacy_sandbox {
+        pub mod tvs {
+            include!(concat!(env!("OUT_DIR"), "/privacy_sandbox.tvs.rs"));
+        }
+    }
 }
 
 mod qemu;
@@ -105,6 +110,10 @@ pub struct Args {
     // Method of communication with the trusted application in the enclave.
     #[arg(long, value_enum, default_value_t = ChannelType::default())]
     pub communication_channel: ChannelType,
+
+    // Address of a tee verification service.
+    #[arg(long, required = true, default_value = "http://localhost:4444")]
+    pub tvs_address: String,
 }
 
 impl Args {
@@ -119,6 +128,7 @@ impl Args {
             application_config: Vec::new(),
             qemu_params: qemu::Params::default_for_root(root),
             communication_channel: ChannelType::default(),
+            tvs_address: "http://localhost:4444".to_string(),
         }
     }
 }
@@ -203,6 +213,7 @@ impl Launcher {
             evidence_sender,
             app_notifier_sender,
             shutdown_receiver,
+            args.tvs_address,
         ));
 
         let trusted_app_channel = match args.communication_channel {
diff --git a/oak_containers_launcher/src/qemu.rs b/oak_containers_launcher/src/qemu.rs
index f24b46c42..f364b3b4b 100644
--- a/oak_containers_launcher/src/qemu.rs
+++ b/oak_containers_launcher/src/qemu.rs
@@ -141,7 +141,10 @@ impl Qemu {
         // restart should be treated as a failure)
         cmd.arg("-no-reboot");
         // Use the `microvm` machine as the basis, and ensure ACPI and PCIe are enabled.
-        cmd.args(["-machine", "microvm,acpi=on,pcie=on,confidential-guest-support=sev0,memory-backend=ram1"]);
+        cmd.args([
+            "-machine",
+            "microvm,acpi=on,pcie=on,confidential-guest-support=sev0,memory-backend=ram1",
+        ]);
         cmd.args(["-object", "memory-backend-memfd,id=ram1,size=8G,share=true,reserve=false"]);
         cmd.args(["-object", "sev-snp-guest,id=sev0,cbitpos=51,reduced-phys-bits=1,id-auth="]);
         // Route first serial port to console.
@@ -171,11 +174,12 @@ impl Qemu {
                 "hostfwd=tcp:{host_address}:{host_proxy_port}-{vm_address}:{vm_port}"
             ));
         };
-        netdev_rules.push(format!(
-            "hostfwd=tcp:{host_address}:50051-{vm_address}:50051"
-        ));
+        netdev_rules.push(format!("hostfwd=tcp:{host_address}:50051-{vm_address}:50051"));
         cmd.args(["-netdev", netdev_rules.join(",").as_str()]);
-        cmd.args(["-device", "virtio-net-pci,disable-legacy=on,iommu_platform=true,netdev=netdev,romfile="]);
+        cmd.args([
+            "-device",
+            "virtio-net-pci,disable-legacy=on,iommu_platform=true,netdev=netdev,romfile=",
+        ]);
         if let Some(virtio_guest_cid) = params.virtio_guest_cid {
             cmd.args([
                 "-device",
diff --git a/oak_containers_launcher/src/server.rs b/oak_containers_launcher/src/server.rs
index a1e801f8a..ad056f751 100644
--- a/oak_containers_launcher/src/server.rs
+++ b/oak_containers_launcher/src/server.rs
@@ -48,8 +48,12 @@ use crate::proto::oak::containers::{
         hostlib_key_provisioning_server::{HostlibKeyProvisioning, HostlibKeyProvisioningServer},
         GetGroupKeysResponse, GetKeyProvisioningRoleResponse, KeyProvisioningRole,
     },
-    GetApplicationConfigResponse, GetImageResponse, SendAttestationEvidenceRequest,
+    GetApplicationConfigResponse, GetImageResponse, OakOpaqueMessage,
+    SendAttestationEvidenceRequest,
 };
+use crate::proto::privacy_sandbox::tvs::tee_verification_service_client::TeeVerificationServiceClient;
+use crate::proto::privacy_sandbox::tvs::OpaqueMessage;
+use tokio_stream::{wrappers::ReceiverStream, StreamExt};
 
 // Most gRPC implementations limit message sizes to 4MiB. Let's stay
 // comfortably below that by limiting responses to 3MiB.
@@ -67,6 +71,7 @@ struct LauncherServerImplementation {
     // Will be used to notify the untrusted application that the trusted application is ready and
     // listening on a socket address.
     app_ready_notifier: Mutex<Option<Sender<()>>>,
+    tvs_address: String,
 }
 
 #[tonic::async_trait]
@@ -182,6 +187,73 @@ impl Launcher for LauncherServerImplementation {
             .map_err(|_err| tonic::Status::internal("couldn't send notification".to_string()))?;
         Ok(tonic::Response::new(()))
     }
+
+    type TvsPipeStream = Pin<Box<dyn Stream<Item = Result<OakOpaqueMessage, Status>> + Send>>;
+    async fn tvs_pipe(
+        &self,
+        request: Request<tonic::Streaming<OakOpaqueMessage>>,
+    ) -> Result<Response<Self::TvsPipeStream>, tonic::Status> {
+        let (tx, rx) = tokio::sync::mpsc::channel(1);
+        let (pipe_tx, mut pipe_rx) = tokio::sync::mpsc::channel(1);
+        let (tvs_tx, mut tvs_rx) = tokio::sync::mpsc::channel(1);
+        let mut stream = request.into_inner();
+        let t = tokio::spawn(async move {
+            loop {
+                let Some(op) = stream.next().await else {
+                    break;
+                };
+                // Got message from the Orchestrator, send it to TVS.
+                pipe_tx.send(OpaqueMessage { binary_message: op.unwrap().binary_message }).await;
+                // Wait for TVS response.
+                let tvs_response: OpaqueMessage =
+                    tvs_rx.recv().await.expect("communication with TVS cut short");
+                // Send TVS response to Orchestrator.
+                tx.send(Ok(OakOpaqueMessage { binary_message: tvs_response.binary_message }))
+                    .await
+                    .unwrap();
+            }
+        });
+
+        // Section for contacting external TVS.
+        let mut tvs_client = TeeVerificationServiceClient::connect(self.tvs_address.clone())
+            .await
+            .map_err(|_err| {
+                tonic::Status::internal(format!(
+                    "Couldn't send to remote TVS at {}",
+                    self.tvs_address
+                ))
+            })?;
+        tokio::spawn(async move {
+            let tvs_outbound = async_stream::stream! {
+                while let Some(msg) = pipe_rx.recv().await {
+                    yield msg;
+                };
+            };
+            let tvs_response = tvs_client.verify_report(Request::new(tvs_outbound)).await.unwrap();
+            let mut tvs_inbound = tvs_response.into_inner();
+            let tvs_handle = tokio::spawn(async move {
+                loop {
+                    match tvs_inbound.message().await {
+                        Ok(message) => {
+                            match message {
+                                Some(op) => {
+                                    tvs_tx.send(op).await;
+                                },
+                                None => break,
+                            }
+                        },
+                        Err(e) => {
+                            panic!("Error from TVS {}", e);
+                            break;
+                        }
+                    }
+                }
+            });
+        });
+        // End TVS section
+
+        Ok(Response::new(Box::pin(ReceiverStream::new(rx))))
+    }
 }
 
 #[tonic::async_trait]
@@ -233,7 +305,11 @@ impl LogsService for LauncherServerImplementation {
                             .attributes
                             .iter()
                             .find_map(|x| {
-                                if x.key == "_SYSTEMD_UNIT" { x.value.as_ref() } else { None }
+                                if x.key == "_SYSTEMD_UNIT" {
+                                    x.value.as_ref()
+                                } else {
+                                    None
+                                }
                             })
                             .and_then(|value| value.value.as_ref())
                             .and_then(|value| match value {
@@ -267,6 +343,7 @@ pub async fn new(
     evidence_sender: Sender<Evidence>,
     app_ready_notifier: Sender<()>,
     shutdown: Receiver<()>,
+    tvs_address: String,
 ) -> Result<(), anyhow::Error> {
     let server_impl = Arc::new(LauncherServerImplementation {
         system_image,
@@ -274,6 +351,7 @@ pub async fn new(
         application_config,
         evidence_sender: Mutex::new(Some(evidence_sender)),
         app_ready_notifier: Mutex::new(Some(app_ready_notifier)),
+        tvs_address,
     });
     Server::builder()
         .add_service(LauncherServer::from_arc(server_impl.clone()))
diff --git a/oak_containers_orchestrator/Cargo.toml b/oak_containers_orchestrator/Cargo.toml
index dd38584a5..c821a7e37 100644
--- a/oak_containers_orchestrator/Cargo.toml
+++ b/oak_containers_orchestrator/Cargo.toml
@@ -57,6 +57,8 @@ tokio-util = { version = "*", default-features = false }
 tonic = { workspace = true }
 walkdir = "*"
 zeroize = "*"
+async-stream = { version = "*" }
+hex = {version = "*"}
 
 [build-dependencies]
 oak_grpc_utils = { workspace = true }
diff --git a/oak_containers_orchestrator/build.rs b/oak_containers_orchestrator/build.rs
index 86f98e79f..744a3a052 100644
--- a/oak_containers_orchestrator/build.rs
+++ b/oak_containers_orchestrator/build.rs
@@ -27,9 +27,11 @@ fn main() -> Result<(), Box<dyn std::error::Error>> {
             "../proto/crypto/crypto.proto",
             "../proto/containers/hostlib_key_provisioning.proto",
             "../proto/session/messages.proto",
+            "../../../tvs/proto/tvs_messages.proto",
         ],
         &[
             "..",
+            "../../../",
             // When building with Bazel, the build script doesn't automatically
             // contain the information needed to find the well-known Google
             // protos. So we need to include these paths here.
diff --git a/oak_containers_orchestrator/src/launcher_client.rs b/oak_containers_orchestrator/src/launcher_client.rs
index 44b747ffd..d4a4366ef 100644
--- a/oak_containers_orchestrator/src/launcher_client.rs
+++ b/oak_containers_orchestrator/src/launcher_client.rs
@@ -13,18 +13,30 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
+use std::{fs, fs::File, io::Read};
+
 use anyhow::Context;
 use opentelemetry_otlp::{TonicExporterBuilder, WithExportConfig};
-use tonic::transport::Channel;
-
-use crate::proto::oak::{
-    attestation::v1::Evidence,
-    containers::{
-        launcher_client::LauncherClient as GrpcLauncherClient,
-        v1::{hostlib_key_provisioning_client::HostlibKeyProvisioningClient, KeyProvisioningRole},
-        SendAttestationEvidenceRequest,
+use prost::Message;
+use tonic::{transport::Channel, Request};
+
+use crate::{
+    proto::{
+        oak::{
+            attestation::v1::Evidence,
+            containers::{
+                launcher_client::LauncherClient as GrpcLauncherClient,
+                v1::{
+                    hostlib_key_provisioning_client::HostlibKeyProvisioningClient,
+                    KeyProvisioningRole,
+                },
+                OakOpaqueMessage, SendAttestationEvidenceRequest,
+            },
+            key_provisioning::v1::GroupKeys,
+        },
+        privacy_sandbox::tvs::VerifyReportRequest,
     },
-    key_provisioning::v1::GroupKeys,
+    tvs_client,
 };
 
 /// Utility struct used to interface with the launcher
@@ -32,14 +44,15 @@ pub struct LauncherClient {
     addr: tonic::transport::Uri,
     inner: GrpcLauncherClient<Channel>,
     hostlib_key_provisioning_client: HostlibKeyProvisioningClient<Channel>,
+    tvs_public_key: String,
 }
 
 impl LauncherClient {
-    pub async fn create(addr: tonic::transport::Uri) -> Result<Self, Box<dyn std::error::Error>> {
+    pub async fn create(addr: tonic::transport::Uri, tvs_public_key: String) -> Result<Self, Box<dyn std::error::Error>> {
         let channel = Channel::builder(addr.clone()).connect().await?;
         let inner = GrpcLauncherClient::new(channel.clone());
         let hostlib_key_provisioning_client = HostlibKeyProvisioningClient::new(channel);
-        Ok(Self { addr, inner, hostlib_key_provisioning_client })
+        Ok(Self { addr, inner, hostlib_key_provisioning_client, tvs_public_key })
     }
 
     pub async fn get_container_bundle(&self) -> Result<Vec<u8>, Box<dyn std::error::Error>> {
@@ -123,4 +136,64 @@ impl LauncherClient {
     pub fn openmetrics_builder(&self) -> TonicExporterBuilder {
         opentelemetry_otlp::new_exporter().tonic().with_endpoint(self.addr.clone().to_string())
     }
+    pub async fn pipe_evidence(
+        &self,
+        evidence: Evidence,
+    ) -> Result<(), Box<dyn std::error::Error>> {
+        let vcek = get_vcek_bytes();
+        let mut tvs = tvs_client::new_tvs_client(&self.tvs_public_key)?;
+        let (tx, mut rx) = tokio::sync::mpsc::channel(1);
+        let outbound = async_stream::stream! {
+            let handshake_initial = OakOpaqueMessage{
+                binary_message: tvs.build_initial_message().unwrap(),
+            };
+            yield handshake_initial;
+            let handshake_response : OakOpaqueMessage = rx.recv().await.unwrap();
+            tvs.process_handshake_response(handshake_response.binary_message.as_slice()).unwrap();
+            let mut verify_report_request_bin: Vec<u8> = Vec::with_capacity(256);
+            VerifyReportRequest {
+                evidence: Some(evidence),
+                tee_certificate: vcek,
+            }
+            .encode(&mut verify_report_request_bin)
+            .unwrap();
+            let command = tvs.build_command(verify_report_request_bin.as_slice()).unwrap();
+            let command =  OakOpaqueMessage {
+                binary_message: command,
+            };
+            yield command;
+            let token_bin = rx.recv().await.unwrap();
+            let token = tvs.process_response(token_bin.binary_message.as_slice()).unwrap();
+            println!("XXX token is {}", token);
+        };
+
+        let response = self.inner.clone().tvs_pipe(Request::new(outbound)).await?;
+        let mut inbound = response.into_inner();
+        let handle = tokio::spawn(async move {
+            loop {
+                match inbound.message().await {
+                    Ok(message) => {
+                        match message {
+                            Some(op) => {
+                                tx.send(op).await;
+                            }
+                            None => break,
+                        }
+                    },
+                    Err(e) => panic!("Error from launcher {}", e),
+                }
+            }
+        });
+        handle.await?;
+
+        Ok(())
+    }
+}
+
+fn get_vcek_bytes() -> Vec<u8> {
+    let mut f = File::open("/usr/vcek_genoa.crt").expect("no vcek file found");
+    let metadata = fs::metadata("/usr/vcek_genoa.crt").expect("unable to read metadata");
+    let mut buffer = vec![0; metadata.len() as usize];
+    f.read(&mut buffer).expect("error reading bytes from vcek");
+    buffer
 }
diff --git a/oak_containers_orchestrator/src/lib.rs b/oak_containers_orchestrator/src/lib.rs
index 9e9c4f52c..1e013c864 100644
--- a/oak_containers_orchestrator/src/lib.rs
+++ b/oak_containers_orchestrator/src/lib.rs
@@ -32,6 +32,11 @@ pub mod proto {
             }
         }
     }
+    pub mod privacy_sandbox {
+        pub mod tvs {
+            include!(concat!(env!("OUT_DIR"), "/privacy_sandbox.tvs.rs"));
+        }
+    }
 }
 
 pub mod container_runtime;
@@ -42,3 +47,4 @@ pub mod key_provisioning;
 pub mod launcher_client;
 pub mod logging;
 pub mod metrics;
+pub mod tvs_client;
diff --git a/oak_containers_orchestrator/src/main.rs b/oak_containers_orchestrator/src/main.rs
index 22961d679..cd1a93978 100644
--- a/oak_containers_orchestrator/src/main.rs
+++ b/oak_containers_orchestrator/src/main.rs
@@ -42,6 +42,9 @@ struct Args {
 
     #[arg(long, default_value = "oakc")]
     runtime_user: String,
+
+    #[arg(long, default_value = "", required = true)]
+    tvs_public_key: String,
 }
 
 #[tokio::main]
@@ -51,7 +54,7 @@ async fn main() -> anyhow::Result<()> {
     let args = Args::parse();
 
     let launcher_client = Arc::new(
-        LauncherClient::create(args.launcher_addr.parse()?)
+        LauncherClient::create(args.launcher_addr.parse()?, args.tvs_public_key)
             .await
             .map_err(|error| anyhow!("couldn't create client: {:?}", error))?,
     );
@@ -100,10 +103,15 @@ async fn main() -> anyhow::Result<()> {
         None,
     )?;
     launcher_client
-        .send_attestation_evidence(evidence)
+        .send_attestation_evidence(evidence.clone())
         .await
         .map_err(|error| anyhow!("couldn't send attestation evidence: {:?}", error))?;
 
+    launcher_client
+        .pipe_evidence(evidence)
+        .await
+        .map_err(|error| anyhow!("couldn't pipe: {:?}", error))?;
+
     // Request group keys.
     if key_provisioning_role == KeyProvisioningRole::Follower {
         let get_group_keys_response = launcher_client
diff --git a/oak_containers_orchestrator/src/tvs_client.rs b/oak_containers_orchestrator/src/tvs_client.rs
index d3a510ac7..f8b39919a 100644
--- a/oak_containers_orchestrator/src/tvs_client.rs
+++ b/oak_containers_orchestrator/src/tvs_client.rs
@@ -1,5 +1,3 @@
-#![no_main] // main defined in C++ by main.cc
-
 extern crate hex;
 use crate::proto::privacy_sandbox::tvs::{
     attest_report_request, attest_report_response, AttestReportRequest, AttestReportResponse,
@@ -11,27 +9,7 @@ use oak_crypto::noise_handshake::{Crypter, P256_X962_LEN};
 
 use prost::Message;
 
-pub mod proto {
-    pub mod privacy_sandbox {
-        pub mod tvs {
-            include!(concat!(env!("OUT_DIR"), "/privacy_sandbox.tvs.rs"));
-        }
-    }
-}
-
-#[cxx::bridge(namespace = "privacy_sandbox::tvs::test_client")]
-mod ffi {
-    extern "Rust" {
-        type TvsClient;
-        fn new_tvs_client(tvs_pub_key: &str) -> Result<Box<TvsClient>>;
-        fn build_initial_message(&mut self) -> Result<Vec<u8>>;
-        fn process_handshake_response(&mut self, response: &[u8]) -> Result<()>;
-        fn build_command(&mut self, message: &[u8]) -> Result<Vec<u8>>;
-        fn process_response(&mut self, response: &[u8]) -> Result<String>;
-    }
-}
-
-fn new_tvs_client(tvs_pub_key: &str) -> Result<Box<TvsClient>, String> {
+pub fn new_tvs_client(tvs_pub_key: &str) -> Result<Box<TvsClient>, String> {
     let tvs_pub_key = hex::decode(tvs_pub_key)
         .map_err(|_| "Cannot decode tvs_pub_key. The key is expected to be in hex format")?;
     let tvs_pub_key_bytes: [u8; P256_X962_LEN] = tvs_pub_key
@@ -40,7 +18,7 @@ fn new_tvs_client(tvs_pub_key: &str) -> Result<Box<TvsClient>, String> {
     Ok(Box::new(TvsClient::new(&tvs_pub_key_bytes)))
 }
 
-struct TvsClient {
+pub struct TvsClient {
     handshake: HandshakeInitiator,
     crypter: Option<Crypter>,
 }
@@ -53,7 +31,7 @@ impl TvsClient {
         }
     }
 
-    fn build_initial_message(&mut self) -> Result<Vec<u8>, String> {
+    pub fn build_initial_message(&mut self) -> Result<Vec<u8>, String> {
         let mut message_bin: Vec<u8> = Vec::with_capacity(256);
         AttestReportRequest {
             request: Some(attest_report_request::Request::InitSessionRequest(
@@ -67,7 +45,7 @@ impl TvsClient {
         Ok(message_bin)
     }
 
-    fn process_handshake_response(&mut self, response: &[u8]) -> Result<(), String> {
+    pub fn process_handshake_response(&mut self, response: &[u8]) -> Result<(), String> {
         let message_reponse: AttestReportResponse = prost::Message::decode(response)
             .map_err(|_| "process_handshake_response() failed. Error decoding message to AttestReportResponse proto.".to_string())?;
         let handshake_response = match &message_reponse.response {
@@ -85,7 +63,7 @@ impl TvsClient {
         Ok(())
     }
 
-    fn build_command(&mut self, message: &[u8]) -> Result<Vec<u8>, String> {
+    pub fn build_command(&mut self, message: &[u8]) -> Result<Vec<u8>, String> {
         if let Some(crypter) = self.crypter.as_mut() {
             match crypter.encrypt(message) {
                 Ok(cipher) => {
@@ -108,7 +86,7 @@ impl TvsClient {
         }
     }
 
-    fn process_response(&mut self, response: &[u8]) -> Result<String, String> {
+    pub fn process_response(&mut self, response: &[u8]) -> Result<String, String> {
         let Some(crypter) = self.crypter.as_mut() else {
             return Err(
                 "Handshake initiation should be done before encrypting messages".to_string(),
diff --git a/oak_containers_syslogd/src/main.rs b/oak_containers_syslogd/src/main.rs
index ad9cc8958..5f5a918c0 100644
--- a/oak_containers_syslogd/src/main.rs
+++ b/oak_containers_syslogd/src/main.rs
@@ -34,6 +34,8 @@ use tokio_stream::StreamExt;
 struct Args {
     #[arg(default_value = "http://10.0.2.100:8080")]
     launcher_addr: String,
+    #[arg(default_value = "00")]
+    tvs_public_key: String,
 }
 
 #[allow(clippy::never_loop)]
@@ -57,7 +59,7 @@ async fn main() -> Result<(), Box<dyn std::error::Error>> {
     set_error_handler(|err| eprintln!("oak-syslogd: OTLP error: {}", err))?;
 
     let term = Arc::new(OnceCell::new());
-    let launcher_client = LauncherClient::create(args.launcher_addr.parse()?)
+    let launcher_client = LauncherClient::create(args.launcher_addr.parse()?, args.tvs_public_key)
         .await
         .map_err(|error| anyhow!("couldn't create client: {:?}", error))?;
 
diff --git a/oak_containers_system_image/BUILD b/oak_containers_system_image/BUILD
index 150dae588..388358fe2 100644
--- a/oak_containers_system_image/BUILD
+++ b/oak_containers_system_image/BUILD
@@ -28,6 +28,7 @@ filegroup(
         "target/image_binaries/oak_containers_orchestrator",
         "target/image_binaries/oak_containers_syslogd",
         "target/image_binaries/kv-server",
+        "target/image_binaries/vcek_genoa.crt",
     ],
     # This rule will fail unless build-bazel.sh has been run.
     tags = ["noci"],
diff --git a/oak_containers_system_image/Dockerfile b/oak_containers_system_image/Dockerfile
index b9fa4ada2..d405c1536 100644
--- a/oak_containers_system_image/Dockerfile
+++ b/oak_containers_system_image/Dockerfile
@@ -40,6 +40,9 @@ RUN systemctl enable oak-syslogd
 COPY ./target/kv-server /usr/bin/kv-server
 RUN systemctl enable kv-server
 
+# Copy vcek certificate.
+COPY ./target/vcek_genoa.crt /usr/vcek_genoa.crt
+
 # Only enable interactive logins if the kernel was booted with "debug" flag.
 RUN systemctl disable getty@
 RUN systemctl enable root-passwd
diff --git a/oak_functions_containers_app/src/main.rs b/oak_functions_containers_app/src/main.rs
index a8895d2f8..3707bde08 100644
--- a/oak_functions_containers_app/src/main.rs
+++ b/oak_functions_containers_app/src/main.rs
@@ -111,7 +111,7 @@ async fn main() -> Result<(), Box<dyn std::error::Error>> {
     let args = Args::parse();
 
     let launcher_client = Arc::new(
-        LauncherClient::create(args.launcher_addr.parse()?)
+        LauncherClient::create(args.launcher_addr.parse()?, "http://localhost:7777".to_string())
             .await
             .map_err(|error| anyhow!("couldn't create client: {:?}", error))?,
     );
diff --git a/proto/containers/interfaces.proto b/proto/containers/interfaces.proto
index 8c2b7b921..d8c6eed06 100644
--- a/proto/containers/interfaces.proto
+++ b/proto/containers/interfaces.proto
@@ -38,6 +38,10 @@ message SendAttestationEvidenceRequest {
   oak.attestation.v1.Evidence dice_evidence = 2;
 }
 
+message OakOpaqueMessage {
+  bytes binary_message = 1;
+}
+
 // Defines the service exposed by the launcher, that can be invoked by the
 // stage1 and the orchestrator.
 service Launcher {
@@ -66,6 +70,9 @@ service Launcher {
   // Notifies the launcher that the trusted app is ready to serve requests and
   // listening on the pre-arranged port (8080).
   rpc NotifyAppReady(google.protobuf.Empty) returns (google.protobuf.Empty) {}
+
+  // Rpc to pipe requests from the orchestrator to a TVS server.
+  rpc TvsPipe(stream OakOpaqueMessage) returns (stream OakOpaqueMessage) {}
 }
 
 // Defines the service exposed by the orchestrator, that can be invoked by the
